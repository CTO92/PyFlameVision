// Grid Sample CSL Template for Cerebras WSE
// Performs coordinate-based sampling from input tensor
// Generated by PyFlameVision Phase 4

const WIDTH: u16 = ${width};
const HEIGHT: u16 = ${height};
const CHANNELS: u16 = ${channels};
const OUT_WIDTH: u16 = ${out_width};
const OUT_HEIGHT: u16 = ${out_height};
const HALO_SIZE: u16 = ${halo_size};
const MODE: u8 = ${mode};  // 0=nearest, 1=bilinear
const PADDING_MODE: u8 = ${padding_mode};  // 0=zeros, 1=border, 2=reflection
const ALIGN_CORNERS: bool = ${align_corners};

// Tile dimensions including halo
const TILE_WIDTH: u16 = WIDTH + 2 * HALO_SIZE;
const TILE_HEIGHT: u16 = HEIGHT + 2 * HALO_SIZE;

// Input buffer with halo region
var input_buffer: [CHANNELS][TILE_HEIGHT][TILE_WIDTH]f32;
// Grid buffer (normalized coordinates)
var grid_buffer: [OUT_HEIGHT][OUT_WIDTH][2]f32;
// Output buffer
var output_buffer: [CHANNELS][OUT_HEIGHT][OUT_WIDTH]f32;

// Convert normalized coordinate to pixel coordinate
fn denormalize_coord(coord: f32, size: u16) f32 {
    const size_f = @as(f32, size);
    if (ALIGN_CORNERS) {
        // -1 maps to 0, 1 maps to size-1
        return (coord + 1.0) * 0.5 * (size_f - 1.0);
    } else {
        // -1 maps to -0.5, 1 maps to size-0.5
        return ((coord + 1.0) * size_f - 1.0) * 0.5;
    }
}

// Apply padding mode to get valid coordinate
fn apply_padding(coord: f32, size: u16) f32 {
    const size_f = @as(f32, size);
    if (PADDING_MODE == 0) {
        // Zeros: return as-is (will check bounds when sampling)
        return coord;
    } else if (PADDING_MODE == 1) {
        // Border: clamp to [0, size-1]
        return @max(0.0, @min(coord, size_f - 1.0));
    } else {
        // Reflection: reflect at boundaries
        var c = coord;
        if (c < 0.0) {
            c = -c;
        }
        // Reflect within [0, 2*size)
        c = @mod(c, 2.0 * size_f);
        if (c >= size_f) {
            c = 2.0 * size_f - c - 1.0;
        }
        return c;
    }
}

// Check if coordinate is within bounds
fn is_in_bounds(x: i32, y: i32, w: u16, h: u16) bool {
    return x >= 0 and x < @as(i32, w) and y >= 0 and y < @as(i32, h);
}

// Bilinear interpolation at a point
fn sample_bilinear(c: u16, x: f32, y: f32) f32 {
    const x0 = @floatToInt(i32, @floor(x));
    const y0 = @floatToInt(i32, @floor(y));
    const x1 = x0 + 1;
    const y1 = y0 + 1;

    const wx = x - @intToFloat(f32, x0);
    const wy = y - @intToFloat(f32, y0);

    // Get values at four corners (with bounds checking)
    var v00: f32 = 0.0;
    var v01: f32 = 0.0;
    var v10: f32 = 0.0;
    var v11: f32 = 0.0;

    if (PADDING_MODE == 0) {
        // Zeros padding: check each corner
        if (is_in_bounds(x0, y0, WIDTH, HEIGHT)) {
            v00 = input_buffer[c][@intCast(u16, y0) + HALO_SIZE][@intCast(u16, x0) + HALO_SIZE];
        }
        if (is_in_bounds(x1, y0, WIDTH, HEIGHT)) {
            v10 = input_buffer[c][@intCast(u16, y0) + HALO_SIZE][@intCast(u16, x1) + HALO_SIZE];
        }
        if (is_in_bounds(x0, y1, WIDTH, HEIGHT)) {
            v01 = input_buffer[c][@intCast(u16, y1) + HALO_SIZE][@intCast(u16, x0) + HALO_SIZE];
        }
        if (is_in_bounds(x1, y1, WIDTH, HEIGHT)) {
            v11 = input_buffer[c][@intCast(u16, y1) + HALO_SIZE][@intCast(u16, x1) + HALO_SIZE];
        }
    } else {
        // Border/reflection: coordinates already clamped
        const px0 = @intCast(u16, @max(0, @min(x0, @as(i32, WIDTH) - 1)));
        const py0 = @intCast(u16, @max(0, @min(y0, @as(i32, HEIGHT) - 1)));
        const px1 = @intCast(u16, @max(0, @min(x1, @as(i32, WIDTH) - 1)));
        const py1 = @intCast(u16, @max(0, @min(y1, @as(i32, HEIGHT) - 1)));

        v00 = input_buffer[c][py0 + HALO_SIZE][px0 + HALO_SIZE];
        v10 = input_buffer[c][py0 + HALO_SIZE][px1 + HALO_SIZE];
        v01 = input_buffer[c][py1 + HALO_SIZE][px0 + HALO_SIZE];
        v11 = input_buffer[c][py1 + HALO_SIZE][px1 + HALO_SIZE];
    }

    // Bilinear interpolation
    const v0 = v00 * (1.0 - wx) + v10 * wx;
    const v1 = v01 * (1.0 - wx) + v11 * wx;
    return v0 * (1.0 - wy) + v1 * wy;
}

// Nearest neighbor sampling
fn sample_nearest(c: u16, x: f32, y: f32) f32 {
    const xi = @floatToInt(i32, @round(x));
    const yi = @floatToInt(i32, @round(y));

    if (PADDING_MODE == 0) {
        if (!is_in_bounds(xi, yi, WIDTH, HEIGHT)) {
            return 0.0;
        }
    }

    const px = @intCast(u16, @max(0, @min(xi, @as(i32, WIDTH) - 1)));
    const py = @intCast(u16, @max(0, @min(yi, @as(i32, HEIGHT) - 1)));

    return input_buffer[c][py + HALO_SIZE][px + HALO_SIZE];
}

// Main grid sample computation
fn compute_grid_sample() void {
    var oy: u16 = 0;
    while (oy < OUT_HEIGHT) : (oy += 1) {
        var ox: u16 = 0;
        while (ox < OUT_WIDTH) : (ox += 1) {
            // Get normalized coordinates from grid
            const norm_x = grid_buffer[oy][ox][0];
            const norm_y = grid_buffer[oy][ox][1];

            // Denormalize to pixel coordinates
            var px = denormalize_coord(norm_x, WIDTH);
            var py = denormalize_coord(norm_y, HEIGHT);

            // Apply padding mode
            px = apply_padding(px, WIDTH);
            py = apply_padding(py, HEIGHT);

            // Sample each channel
            var c: u16 = 0;
            while (c < CHANNELS) : (c += 1) {
                if (MODE == 0) {
                    output_buffer[c][oy][ox] = sample_nearest(c, px, py);
                } else {
                    output_buffer[c][oy][ox] = sample_bilinear(c, px, py);
                }
            }
        }
    }
}

// Task entry point
task grid_sample_task() void {
    // Exchange halo regions with neighbors (PE communication)
    @import_module("<halo_exchange>").exchange_halo(&input_buffer, HALO_SIZE);

    // Synchronize before computation
    @import_module("<sync>").barrier();

    // Perform grid sampling
    compute_grid_sample();

    // Signal completion
    @import_module("<sync>").signal_done();
}

comptime {
    @bind_task(grid_sample_task);
}
