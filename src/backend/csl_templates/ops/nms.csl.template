// Non-Maximum Suppression CSL Template for Cerebras WSE
// Filters overlapping detection boxes
// Generated by PyFlameVision Phase 4

const MAX_BOXES: u16 = ${max_boxes};
const IOU_THRESHOLD: f32 = ${iou_threshold};

// Box buffer: [x1, y1, x2, y2, score] per box
var boxes: [MAX_BOXES][5]f32;
// Suppression mask (true = suppressed)
var suppressed: [MAX_BOXES]bool;
// Output indices of kept boxes
var kept_indices: [MAX_BOXES]u16;
var num_kept: u16 = 0;
var num_boxes: u16 = 0;

// Compute area of a box
fn box_area(idx: u16) f32 {
    const x1 = boxes[idx][0];
    const y1 = boxes[idx][1];
    const x2 = boxes[idx][2];
    const y2 = boxes[idx][3];
    return @max(0.0, x2 - x1) * @max(0.0, y2 - y1);
}

// Compute IoU between two boxes
fn compute_iou(i: u16, j: u16) f32 {
    const i_x1 = boxes[i][0];
    const i_y1 = boxes[i][1];
    const i_x2 = boxes[i][2];
    const i_y2 = boxes[i][3];

    const j_x1 = boxes[j][0];
    const j_y1 = boxes[j][1];
    const j_x2 = boxes[j][2];
    const j_y2 = boxes[j][3];

    // Intersection
    const inter_x1 = @max(i_x1, j_x1);
    const inter_y1 = @max(i_y1, j_y1);
    const inter_x2 = @min(i_x2, j_x2);
    const inter_y2 = @min(i_y2, j_y2);

    const inter_w = @max(0.0, inter_x2 - inter_x1);
    const inter_h = @max(0.0, inter_y2 - inter_y1);
    const inter_area = inter_w * inter_h;

    // Union
    const area_i = box_area(i);
    const area_j = box_area(j);
    const union_area = area_i + area_j - inter_area;

    if (union_area <= 0.0) {
        return 0.0;
    }
    return inter_area / union_area;
}

// Get score of a box
fn box_score(idx: u16) f32 {
    return boxes[idx][4];
}

// Find index of maximum score among non-suppressed boxes
fn find_max_score_idx() ?u16 {
    var max_idx: ?u16 = null;
    var max_score: f32 = -1e30;

    var i: u16 = 0;
    while (i < num_boxes) : (i += 1) {
        if (!suppressed[i]) {
            const score = box_score(i);
            if (score > max_score) {
                max_score = score;
                max_idx = i;
            }
        }
    }
    return max_idx;
}

// Main NMS computation (greedy algorithm)
fn compute_nms() void {
    // Initialize suppression mask
    var i: u16 = 0;
    while (i < MAX_BOXES) : (i += 1) {
        suppressed[i] = false;
    }
    num_kept = 0;

    // Greedy NMS loop
    while (true) {
        // Find highest scoring non-suppressed box
        const max_idx_opt = find_max_score_idx();
        if (max_idx_opt == null) {
            break;
        }
        const keep_idx = max_idx_opt.?;

        // Keep this box
        kept_indices[num_kept] = keep_idx;
        num_kept += 1;
        suppressed[keep_idx] = true;

        // Suppress overlapping boxes
        var j: u16 = 0;
        while (j < num_boxes) : (j += 1) {
            if (!suppressed[j]) {
                const iou = compute_iou(keep_idx, j);
                if (iou > IOU_THRESHOLD) {
                    suppressed[j] = true;
                }
            }
        }
    }
}

// For distributed NMS across PE mesh, need reduction
// This is a simplified version; full implementation requires
// cross-PE communication for global NMS

// Task entry point
task nms_task() void {
    // Perform local NMS
    compute_nms();

    // For distributed execution, results need to be gathered
    // and global NMS performed (or use class-aware batched approach)
    @import_module("<sync>").signal_done();
}

comptime {
    @bind_task(nms_task);
}
