// ROI Align CSL Template for Cerebras WSE
// Extracts fixed-size features from regions of interest
// Generated by PyFlameVision Phase 4

const INPUT_HEIGHT: u16 = ${input_height};
const INPUT_WIDTH: u16 = ${input_width};
const CHANNELS: u16 = ${channels};
const OUTPUT_HEIGHT: u16 = ${output_height};
const OUTPUT_WIDTH: u16 = ${output_width};
const SPATIAL_SCALE: f32 = ${spatial_scale};
const SAMPLING_RATIO: u16 = ${sampling_ratio};
const ALIGNED: bool = ${aligned};
const NUM_ROIS: u16 = ${num_rois};
const HALO_SIZE: u16 = 1;

// Tile dimensions including halo
const TILE_HEIGHT: u16 = INPUT_HEIGHT + 2 * HALO_SIZE;
const TILE_WIDTH: u16 = INPUT_WIDTH + 2 * HALO_SIZE;

// Input feature map with halo
var input_buffer: [CHANNELS][TILE_HEIGHT][TILE_WIDTH]f32;
// ROI buffer: [batch_idx, x1, y1, x2, y2] per ROI
var roi_buffer: [NUM_ROIS][5]f32;
// Output buffer
var output_buffer: [NUM_ROIS][CHANNELS][OUTPUT_HEIGHT][OUTPUT_WIDTH]f32;

// Bilinear interpolation at fractional coordinate
fn bilinear_sample(c: u16, x: f32, y: f32) f32 {
    const x_low = @floatToInt(i32, @floor(x));
    const y_low = @floatToInt(i32, @floor(y));
    const x_high = x_low + 1;
    const y_high = y_low + 1;

    const lx = x - @intToFloat(f32, x_low);
    const ly = y - @intToFloat(f32, y_low);
    const hx = 1.0 - lx;
    const hy = 1.0 - ly;

    // Clamp to valid range
    const px_low = @intCast(u16, @max(0, @min(x_low, @as(i32, INPUT_WIDTH) - 1)));
    const py_low = @intCast(u16, @max(0, @min(y_low, @as(i32, INPUT_HEIGHT) - 1)));
    const px_high = @intCast(u16, @max(0, @min(x_high, @as(i32, INPUT_WIDTH) - 1)));
    const py_high = @intCast(u16, @max(0, @min(y_high, @as(i32, INPUT_HEIGHT) - 1)));

    // Get four corner values (with halo offset)
    const v1 = input_buffer[c][py_low + HALO_SIZE][px_low + HALO_SIZE];
    const v2 = input_buffer[c][py_low + HALO_SIZE][px_high + HALO_SIZE];
    const v3 = input_buffer[c][py_high + HALO_SIZE][px_low + HALO_SIZE];
    const v4 = input_buffer[c][py_high + HALO_SIZE][px_high + HALO_SIZE];

    // Bilinear weights
    const w1 = hy * hx;
    const w2 = hy * lx;
    const w3 = ly * hx;
    const w4 = ly * lx;

    return w1 * v1 + w2 * v2 + w3 * v3 + w4 * v4;
}

// Process single ROI
fn process_roi(roi_idx: u16) void {
    // Get ROI coordinates (already scaled)
    const x1 = roi_buffer[roi_idx][1] * SPATIAL_SCALE;
    const y1 = roi_buffer[roi_idx][2] * SPATIAL_SCALE;
    const x2 = roi_buffer[roi_idx][3] * SPATIAL_SCALE;
    const y2 = roi_buffer[roi_idx][4] * SPATIAL_SCALE;

    // Apply alignment offset
    var roi_x1 = x1;
    var roi_y1 = y1;
    var roi_x2 = x2;
    var roi_y2 = y2;

    if (ALIGNED) {
        roi_x1 = roi_x1 - 0.5;
        roi_y1 = roi_y1 - 0.5;
        roi_x2 = roi_x2 - 0.5;
        roi_y2 = roi_y2 - 0.5;
    }

    const roi_width = @max(roi_x2 - roi_x1, 1.0);
    const roi_height = @max(roi_y2 - roi_y1, 1.0);

    const bin_width = roi_width / @intToFloat(f32, OUTPUT_WIDTH);
    const bin_height = roi_height / @intToFloat(f32, OUTPUT_HEIGHT);

    // Determine sampling points per bin
    var roi_bin_grid_h: u16 = SAMPLING_RATIO;
    var roi_bin_grid_w: u16 = SAMPLING_RATIO;
    if (SAMPLING_RATIO == 0) {
        roi_bin_grid_h = @max(1, @floatToInt(u16, @ceil(bin_height)));
        roi_bin_grid_w = @max(1, @floatToInt(u16, @ceil(bin_width)));
    }

    const count = @intToFloat(f32, roi_bin_grid_h * roi_bin_grid_w);

    // Process each output bin
    var ph: u16 = 0;
    while (ph < OUTPUT_HEIGHT) : (ph += 1) {
        var pw: u16 = 0;
        while (pw < OUTPUT_WIDTH) : (pw += 1) {
            // For each channel
            var c: u16 = 0;
            while (c < CHANNELS) : (c += 1) {
                var sum: f32 = 0.0;

                // Sample within bin
                var iy: u16 = 0;
                while (iy < roi_bin_grid_h) : (iy += 1) {
                    const y = roi_y1 + @intToFloat(f32, ph) * bin_height +
                              (@intToFloat(f32, iy) + 0.5) * bin_height / @intToFloat(f32, roi_bin_grid_h);

                    var ix: u16 = 0;
                    while (ix < roi_bin_grid_w) : (ix += 1) {
                        const x = roi_x1 + @intToFloat(f32, pw) * bin_width +
                                  (@intToFloat(f32, ix) + 0.5) * bin_width / @intToFloat(f32, roi_bin_grid_w);

                        sum += bilinear_sample(c, x, y);
                    }
                }

                output_buffer[roi_idx][c][ph][pw] = sum / count;
            }
        }
    }
}

// Main ROI Align computation
fn compute_roi_align() void {
    var roi_idx: u16 = 0;
    while (roi_idx < NUM_ROIS) : (roi_idx += 1) {
        process_roi(roi_idx);
    }
}

// Task entry point
task roi_align_task() void {
    // Exchange halo regions
    @import_module("<halo_exchange>").exchange_halo(&input_buffer, HALO_SIZE);

    // Synchronize
    @import_module("<sync>").barrier();

    // Perform ROI alignment
    compute_roi_align();

    // Signal completion
    @import_module("<sync>").signal_done();
}

comptime {
    @bind_task(roi_align_task);
}
